{"version":3,"file":"index.es.js","sources":["../src/useTimeout.ts","../src/defaultTimeoutHandler.ts","../src/useTimeoutDefault.ts"],"sourcesContent":["import { useEffect, useRef } from 'react';\nimport { TimeoutHandler } from './TimeoutHandler';\n\nexport type CancelTimer = () => void;\nexport type UseTimeout = <T>(callback: () => void, timeout: number, timeHandler: TimeoutHandler<T>, deps?: unknown[]) => CancelTimer;\n\n/**\n * useTimeout is a React.js custom hook that sets a leak-safe timeout and returns\n * a function to cancel it before the timeout expires.\n * It's composed of two other native hooks, useRef and useEffect.\n * It requires a custom way of setting a timeout and clearing it, expressed as an implementation\n * of the generic TimeoutHandler<T> interface.\n * The timer is restarted every time an item in `deps` changes.\n * If a new callback is given to the hook before the previous timeout expires,\n * only the new callback will be executed at the moment the timeout expires.\n * When the hook receives a new callback, the timeout isn't reset.\n * \n * @param callback the function to be executed after the timeout expires\n * @param timeout the number of milliseconds after which the callback should be triggered\n * @param timeHandler TimeoutHandler instance that's used to set and clear the timeout\n * @param deps useEffect dependencies that should cause the timeout to be reset\n * @return function to cancel the timer before the timeout expires\n */\nexport const useTimeout: UseTimeout = (callback, timeout, timeHandler, deps = []) => {\n  const refCallback = useRef<() => void>();\n  const refTimer = useRef<(typeof timeHandler) extends TimeoutHandler<infer R> ? R : never | undefined>();\n\n  useEffect(() => {\n    refCallback.current = callback;\n  }, [callback]);\n\n  /**\n   * The timer is restarted every time an item in `deps` changes.\n   * \n   * TODO: The `react-hooks/exhaustive-deps` ESLint warning is disabled due to the fact that\n   * the linter isn't able to detect misused `useEffect` dependencies when given a computed\n   * array (such as `deps`). If possible, another solution that doesn't block the linter\n   * should be used.\n   */\n  useEffect(() => {\n    const timerID = timeHandler.setTimeout(refCallback.current!, timeout);\n    refTimer.current = timerID;\n\n    // cleans the timer identified by timerID when the effect is unmounted.\n    return () => timeHandler.clearTimeout(timerID);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n\n  /**\n   * Returns a function that can be used to cancel the current timeout.\n   * It does so using `timeHandler.clearTimeout` without exposing the last\n   * reference to the timer to the user.\n   */\n  function cancelTimer() {\n    return timeHandler.clearTimeout(refTimer.current);\n  }\n\n  return cancelTimer;\n}\n","import { TimeoutHandler } from './TimeoutHandler';\n\n/**\n * defaultTimeoutHandler implements the TimeoutHandler interface with the usual timer\n * functions available in browsers and in React Native, i.e. `setTimeout` and `clearTimeout`.\n */\nexport const defaultTimeoutHandler: TimeoutHandler<number> = {\n  setTimeout: (fn: () => void, timeout: number) => window.setTimeout(fn, timeout),\n  clearTimeout: (timeout: number | undefined) => { window.clearTimeout(timeout) },\n};\n","import { useTimeout, CancelTimer } from './useTimeout';\nimport { defaultTimeoutHandler } from './defaultTimeoutHandler';\n\nexport type UseTimeoutDefault = (callback: () => void, timeout: number, deps?: unknown[]) => CancelTimer;\n\n/**\n * useTimeoutDefault is a React.js custom hook that sets a leak-safe timeout and returns\n * a function to cancel it before the timeout expires.\n * It uses the default timeout handlers, i.e. window.setTimeout and window.clearTimeout.\n * It's composed of two other native hooks, useRef and useEffect.\n * If a new callback is given to the hook before the previous timeout expires,\n * only the new callback will be executed at the moment the timeout expires.\n * When the hook receives a new callback, the timeout isn't reset.\n * \n * @param callback the function to be executed after the timeout expires\n * @param timeout the number of milliseconds after which the callback should be triggered\n * @param deps useEffect dependencies that should cause the timeout to be reset\n * @return function to cancel the timer before the timeout expires\n */\nexport const useTimeoutDefault: UseTimeoutDefault = (callback, timeout, deps = []) => (\n  useTimeout(callback, timeout, defaultTimeoutHandler, deps)\n);\n"],"names":[],"mappings":";;AAMA;;;;;;;;;;;;;;;;;AAiBA,IAAa,UAAU,GAAe,UAAC,QAAQ,EAAE,OAAO,EAAE,WAAW,EAAE,IAAS;IAAT,qBAAA,EAAA,SAAS;IAC9E,IAAM,WAAW,GAAG,MAAM,EAAc,CAAC;IACzC,IAAM,QAAQ,GAAG,MAAM,EAAgF,CAAC;IAExG,SAAS,CAAC;QACR,WAAW,CAAC,OAAO,GAAG,QAAQ,CAAC;KAChC,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;;;;;;;;;IAUf,SAAS,CAAC;QACR,IAAM,OAAO,GAAG,WAAW,CAAC,UAAU,CAAC,WAAW,CAAC,OAAQ,EAAE,OAAO,CAAC,CAAC;QACtE,QAAQ,CAAC,OAAO,GAAG,OAAO,CAAC;;QAG3B,OAAO,cAAM,OAAA,WAAW,CAAC,YAAY,CAAC,OAAO,CAAC,GAAA,CAAC;;KAEhD,EAAE,IAAI,CAAC,CAAC;;;;;;IAOT,SAAS,WAAW;QAClB,OAAO,WAAW,CAAC,YAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;KACnD;IAED,OAAO,WAAW,CAAC;CACpB;;ACxDD;;;;AAIA,IAAa,qBAAqB,GAA2B;IAC3D,UAAU,EAAE,UAAC,EAAc,EAAE,OAAe,IAAK,OAAA,MAAM,CAAC,UAAU,CAAC,EAAE,EAAE,OAAO,CAAC,GAAA;IAC/E,YAAY,EAAE,UAAC,OAA2B,IAAO,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,CAAA,EAAE;CAChF;;ACJD;;;;;;;;;;;;;;AAcA,IAAa,iBAAiB,GAAsB,UAAC,QAAQ,EAAE,OAAO,EAAE,IAAS;IAAT,qBAAA,EAAA,SAAS;IAAK,QACpF,UAAU,CAAC,QAAQ,EAAE,OAAO,EAAE,qBAAqB,EAAE,IAAI,CAAC;CAC3D;;;;;"}